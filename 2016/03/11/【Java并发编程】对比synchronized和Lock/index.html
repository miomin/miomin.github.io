<!DOCTYPE html>
<html>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?caf55854d144d2d08223e662c290b0a8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>【Java并发编程】对比synchronized和Lock | Miomin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我把Android重难点和读书笔记都整理在github上：https://github.com/miomin/AndroidDifficulty
如果你觉得对你有帮助的话，希望可以star/follow一下哟，我会持续保持更新。


引言：在Java中，可以使用关键字synchronized来实现同步访问，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java并发编程】对比synchronized和Lock">
<meta property="og:url" content="http://yoursite.com/2016/03/11/【Java并发编程】对比synchronized和Lock/index.html">
<meta property="og:site_name" content="Miomin">
<meta property="og:description" content="我把Android重难点和读书笔记都整理在github上：https://github.com/miomin/AndroidDifficulty
如果你觉得对你有帮助的话，希望可以star/follow一下哟，我会持续保持更新。


引言：在Java中，可以使用关键字synchronized来实现同步访问，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种">
<meta property="og:updated_time" content="2016-04-19T13:35:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Java并发编程】对比synchronized和Lock">
<meta name="twitter:description" content="我把Android重难点和读书笔记都整理在github上：https://github.com/miomin/AndroidDifficulty
如果你觉得对你有帮助的话，希望可以star/follow一下哟，我会持续保持更新。


引言：在Java中，可以使用关键字synchronized来实现同步访问，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种">
  
    <link rel="alternative" href="/atom.xml" title="Miomin" type="application/atom+xml">
  
  
    <link rel="icon" href="/uploads/avatar.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/uploads/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">莫绪旻</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不曾凋谢，待我重生，活着总会有好事发生~</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/miomin" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Andorid/" style="font-size: 15px;">Andorid</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Android学习笔记/" style="font-size: 10px;">Android学习笔记</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/Java并发/" style="font-size: 10px;">Java并发</a> <a href="/tags/Java并发编程/" style="font-size: 10px;">Java并发编程</a> <a href="/tags/个人经验/" style="font-size: 10px;">个人经验</a> <a href="/tags/性能优化/" style="font-size: 20px;">性能优化</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">不曾凋谢，待我重生，活着总会有好事发生~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">莫绪旻</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/uploads/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">莫绪旻</h1>
			</hgroup>
			
			<p class="header-subtitle">不曾凋谢，待我重生，活着总会有好事发生~</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/miomin" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-【Java并发编程】对比synchronized和Lock" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/11/【Java并发编程】对比synchronized和Lock/" class="article-date">
  	<time datetime="2016-03-11T09:15:00.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【Java并发编程】对比synchronized和Lock
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java并发/">Java并发</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em>我把Android重难点和读书笔记都整理在github上：</em></strong><a href="https://github.com/miomin/AndroidDifficulty" target="_blank" rel="external">https://github.com/miomin/AndroidDifficulty</a></p>
<p><strong><em>如果你觉得对你有帮助的话，希望可以star/follow一下哟，我会持续保持更新。</em></strong></p>
<hr>
<ul>
<li><strong><em>引言：</em></strong>在Java中，可以使用关键字synchronized来实现同步访问，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？那得先从synchronized的缺陷讲起。</li>
</ul>
<p>转载自海子的博文：<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="external">《Java并发编程：Lock》</a></p>
<hr>
<h2 id="一、synchronized的缺陷"><a href="#一、synchronized的缺陷" class="headerlink" title="一、synchronized的缺陷"></a>一、synchronized的缺陷</h2><p>　　synchronized是java中的一个关键字，也就是说是JVM内置的特性，加锁到释放所的所有过程都由JVM来完成，程序员是不可见的。</p>
<p>　　如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p>
<p>　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p>
<p>　　2）线程执行发生异常，此时JVM会让线程自动释放锁。</p>
<p>　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p>
<p>　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p>　　再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p>
<p>　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p>
<p>　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p>
<p>　　因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p>
<p>　　另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p>
<p>　　总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p>
<p>　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p>
<p>　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p>
<hr>
<a id="more"></a>
<h2 id="二、java-util-concurrent-locks包下常用的类"><a href="#二、java-util-concurrent-locks包下常用的类" class="headerlink" title="二、java.util.concurrent.locks包下常用的类"></a>二、java.util.concurrent.locks包下常用的类</h2><h3 id="1、Lock"><a href="#1、Lock" class="headerlink" title="1、Lock"></a>1、Lock</h3><p>首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口。</p>
<p>　　首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p>
<p>　　由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    //处理任务</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();   //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p>
<p>　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p>
<p>　　所以，一般情况下通过tryLock来获取锁时是这样使用的：
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">if(lock.tryLock()) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">         //处理任务</span><br><span class="line">     &#125;catch(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;finally&#123;</span><br><span class="line">         lock.unlock();   //释放锁</span><br><span class="line">     &#125; </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    //如果不能获取锁，则直接做其他事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p>
<p>　　lockInterruptibly()一般的使用形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws InterruptedException &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;  </span><br><span class="line">     //TODO</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p>
<p>　　而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
<h3 id="2、ReentrantLock"><a href="#2、ReentrantLock" class="headerlink" title="2、ReentrantLock"></a>2、ReentrantLock</h3><p>ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p>
<p><strong><em>例子1，lock()的正确使用方法：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    //注意这个地方，锁一定要是全局变量，不能声明在方法体中</span><br><span class="line">    private Lock lock = new ReentrantLock();    </span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public void insert(Thread thread) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>例子2，tryLock()的使用方法：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    private Lock lock = new ReentrantLock();    //注意这个地方</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public void insert(Thread thread) &#123;</span><br><span class="line">        if(lock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">                for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // TODO: handle exception</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;获取锁失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>例子3，lockInterruptibly()响应中断的使用方法：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();   </span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        MyThread thread1 = new MyThread(test);</span><br><span class="line">        MyThread thread2 = new MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">         </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public void insert(Thread thread) throws InterruptedException&#123;</span><br><span class="line">        lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span><br><span class="line">        try &#123;  </span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            for(    ;     ;) &#123;</span><br><span class="line">                if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    break;</span><br><span class="line">                //插入数据</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private Test test = null;</span><br><span class="line">    public MyThread(Test test) &#123;</span><br><span class="line">        this.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">         </span><br><span class="line">        try &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;被中断&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、ReadWriteLock"><a href="#3、ReadWriteLock" class="headerlink" title="3、ReadWriteLock"></a>3、ReadWriteLock</h3><p>　　ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading.</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing.</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　　一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p>
<h3 id="4、ReentrantReadWriteLock"><a href="#4、ReentrantReadWriteLock" class="headerlink" title="4、ReentrantReadWriteLock"></a>4、ReentrantReadWriteLock</h3><p>　　ReentrantReadWriteLock实现了ReadWriteLock接口。下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</p>
<p>　　假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public synchronized void get(Thread thread) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p>
<p>　　而改成用读写锁的话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public void get(Thread thread) &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">             </span><br><span class="line">            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这样的话，thread1和thread2可以同时进行读操作。这样就大大提升了读操作的效率。<br>　　如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。<br>　　如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。<br>　　总结来说，仅仅允许多个线程同时读，但是在获得写锁的时候，不允许其他线程读或写。</p>
<hr>
<h2 id="三、锁的相关概念介绍"><a href="#三、锁的相关概念介绍" class="headerlink" title="三、锁的相关概念介绍"></a>三、锁的相关概念介绍</h2><h3 id="1、可重入锁"><a href="#1、可重入锁" class="headerlink" title="1、可重入锁"></a>1、可重入锁</h3><p>　　像synchronized和ReentrantLock都是可重入锁，可重入性是说锁的分配机制：是基于线程的分配，而不是基于方法调用的分配。举个例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    public synchronized void method1() &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public synchronized void method2() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。<br>可重入锁的最大好处就是防止死锁，如果没有可重入性，JVM在method1中调用method2的时候，会尝试去获取method2的锁，但是这时候MyClass的锁已经被method1获取了，所以不能分配给method2，这时就发生了死锁。</p>
<h3 id="2、可中断锁"><a href="#2、可中断锁" class="headerlink" title="2、可中断锁"></a>2、可中断锁</h3><p>　　synchronized就不是可中断锁，而Lock是可中断锁。</p>
<p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>　　在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p>
<h3 id="3、公平锁"><a href="#3、公平锁" class="headerlink" title="3、公平锁"></a>3、公平锁</h3><p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。<br>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p>
<h3 id="4、读写锁"><a href="#4、读写锁" class="headerlink" title="4、读写锁"></a>4、读写锁</h3><p>　　读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。<br>　　正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br>　　ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。<br>　　可以通过readLock()获取读锁，通过writeLock()获取写锁。<br>　　上面已经演示过了读写锁的使用方法，在此不再赘述。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/16/【Android性能优化】布局的性能优化/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          【Android性能优化】布局的性能优化
        
      </div>
    </a>
  
  
    <a href="/2016/01/22/【Thinking in Java读书笔记】如何安全的终止线程/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">【Thinking in Java读书笔记】如何安全的终止线程</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="【Java并发编程】对比synchronized和Lock" data-title="【Java并发编程】对比synchronized和Lock" data-url="http://yoursite.com/2016/03/11/【Java并发编程】对比synchronized和Lock/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"miomin"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 莫绪旻
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






  </div>
</body>
</html>